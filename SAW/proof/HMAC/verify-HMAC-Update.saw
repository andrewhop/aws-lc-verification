/* 
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

// Include HMAC helper functions.
include "HMAC-common.saw";

// Specification of the HMAC_Update function
let HMAC_Update_spec num len = do {
  // Precondition: The function uses the AVX+shrd code path
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `digest_ptr` is a pointer to a const `env_md_st` satisfying the
  // `points_to_env_md_st` specification
  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  // Precondition: `hmac_ctx_ptr` is a pointer to an `hmac_ctx_st`
  hmac_ctx_ptr <- crucible_alloc (llvm_struct "struct.hmac_ctx_st");
  // Precondition: `hmac_ctx` is a fresh Cryptol HMACState
  hmac_ctx <- fresh_hmac_state_st "hmac_ctx" num;
  // Precondition: `i_ctx_ptr`, `o_ctx_ptr`, and `md_ctx_ptr` are
  // `sha512_state_st` structs
  (i_ctx_ptr, o_ctx_ptr, md_ctx_ptr) <- alloc_sha512_state_sts;
  // Precondition: `hmac_ctx_ptr` matches `hmac_ctx`
  points_to_hmac_ctx_st hmac_ctx_ptr digest_ptr hmac_ctx num i_ctx_ptr o_ctx_ptr md_ctx_ptr;

  // Precondition: `data` is an array of `len` bytes.  `data_ptr` points
  // to `data`.
  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array len (llvm_int 8));

  // Call function with `hmac_ctx_ptr`, `data_ptr`, and `len`
  crucible_execute_func [ hmac_ctx_ptr , data_ptr , crucible_term {{ `len : [64] }} ];

  // Postcondition: The function has not changed the variable that decides the
  // AVX+shrd code path
  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The data pointed to by `hmac_ctx_ptr` matches the context
  // returned by the cryptol function `HMACInit` when applied to `hmac_ctx` and
  // `data`.
  points_to_hmac_ctx_st hmac_ctx_ptr digest_ptr {{ HMACUpdate hmac_ctx data }} (eval_size {| (num + len) % SHA512_CBLOCK |}) i_ctx_ptr o_ctx_ptr md_ctx_ptr;

  // Postcondition: The function returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

// Verify the `HMAC_Update` C function satisfies the `HMAC_Update_spec`
// specification.  There are 3 cases to consider to ensure the proof covers all
// possible code paths through the update function.
crucible_llvm_verify m "HMAC_Update"
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // num=0, len=240 covers the case with one call to the block function, on one
  // block from data, and the rest of data copied in hmac_ctx->md_ctx->data
  (HMAC_Update_spec 0 240)
  (w4_unint_yices ["processBlock_Common"]);
crucible_llvm_verify m "HMAC_Update"
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // num=0, len=127 covers the case without any calls to the block function,
  // and data copied in ctx->md_ctx->data
  (HMAC_Update_spec 0 127)
  (w4_unint_yices ["processBlock_Common"]);
crucible_llvm_verify m "HMAC_Update"
  [sha512_block_data_order_spec]
  true
  // num=127, len=241 covers the case with two calls to the block function,
  // the first one on ctx->md_ctx->data, the second one on one block from data,
  // and the rest of data copied in ctx->md_ctx->data
  (HMAC_Update_spec 127 241)
  (w4_unint_yices ["processBlock_Common"]);
